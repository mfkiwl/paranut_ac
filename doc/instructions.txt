

ALU
---

111000 ddddd aaaaa bbbbb - 00 ---- 0000         l.add rd, ra, rb
111000 ddddd aaaaa bbbbb - 00 ---- 0001         l.addc rd, ra, rb
111000 ddddd aaaaa bbbbb - 00 ---- 0010         l.sub rd, ra, rb
111000 ddddd aaaaa bbbbb - 00 ---- 0011         l.and rd, ra, rb
111000 ddddd aaaaa bbbbb - 00 ---- 0100         l.or rd, ra, rb
111000 ddddd aaaaa bbbbb - 00 ---- 0101         l.xor rd, ra, rb

111000 ddddd aaaaa bbbbb - 00 00-- 1000         l.sll rd, ra, rb        # rb = no. positions
111000 ddddd aaaaa bbbbb - 00 01-- 1000         l.srl rd, ra, rb        # rb = no. positions
111000 ddddd aaaaa bbbbb - 00 10-- 1000         l.sra rd, ra, rb        # rb = no. positions
111000 ddddd aaaaa bbbbb - 00 11-- 1000 (opt)   l.ror rd, ra, rb        # rb = no. positions

111000 ddddd aaaaa ----- - 00 00-- 1100 (opt)   l.exths rd, ra          # sign-extend half-word
111000 ddddd aaaaa ----- - 00 01-- 1100 (opt)   l.extbs rd, ra          # sign-extend byte
111000 ddddd aaaaa ----- - 00 10-- 1100 (opt)   l.exthz rd, ra          # zero-extend half-word
111000 ddddd aaaaa ----- - 00 11-- 1100 (opt)   l.extbz rd, ra          # zero-extend byte

111000 ddddd aaaaa bbbbb - 00 ---- 1110         l.cmov rd, ra, rb

111000 ddddd aaaaa bbbbb - 11 ---- 0110         l.mul rd, ra, rb        # multiply signed
111000 ddddd aaaaa bbbbb - 11 ---- 1011         l.mulu rd, ra, rb       # multiply unsigned

111000 ddddd aaaaa bbbbb - 11 ---- 1001 (opt)   l.div rd, ra, rb        # divide signed
111000 ddddd aaaaa bbbbb - 11 ---- 1010 (opt)   l.divu rd, ra, rb       # divide unsigned

111000 ddddd aaaaa ----- - 00 ---- 1111 (opt)   l.ff1 rd, ra            # find first 1
111000 ddddd aaaaa ----- - 01 ---- 1111 (opt)   l.fl1 rd, ra            # find last 1

111001 00000 aaaaa bbbbb - -- ---- ----         l.sfeq ra, rb           # set flag if =            [  Z         ]
111001 00001 aaaaa bbbbb - -- ---- ----         l.sfne ra, rb           # set flag if !=           [ !Z         ]
111001 00010 aaaaa bbbbb - -- ---- ----         l.sfgtu ra, rb          # set flag if > unsigned   [ !Z & !C    ]
111001 00011 aaaaa bbbbb - -- ---- ----         l.sfgeu ra, rb          # set flag if >= unsigned  [      !C    ]
111001 00100 aaaaa bbbbb - -- ---- ----         l.sfltu ra, rb          # set flag if < unsigned   [       C
111001 00101 aaaaa bbbbb - -- ---- ----         l.sfleu ra, rb          # set flag if <= unsigned  [  Z |  C    ]
111001 01010 aaaaa bbbbb - -- ---- ----         l.sfgts ra, rb          # set flag if > signed
111001 01011 aaaaa bbbbb - -- ---- ----         l.sfges ra, rb          # set flag if >= signed
111001 01100 aaaaa bbbbb - -- ---- ----         l.sflts ra, rb          # set flag if < signed
111001 01101 aaaaa bbbbb - -- ---- ----         l.sfles ra, rb          # set flag if <= signed

100111 ddddd aaaaa iiiii i ii iiii iiii         l.addi rd, ra, i        # i is sign-extended (exts)
101000 ddddd aaaaa iiiii i ii iiii iiii         l.addic rd, ra, i       # i is sign-extended
101001 ddddd aaaaa iiiii i ii iiii iiii         l.andi rd, ra, i        # i is zero-extended (extz)
101010 ddddd aaaaa iiiii i ii iiii iiii         l.ori rd, ra, i         # i is zero-extended (extz)
101011 ddddd aaaaa iiiii i ii iiii iiii         l.xori rd, ra, i        # i is sign-extended (Note: zero-extended in OR1200)

101100 ddddd aaaaa iiiii i ii iiii iiii         l.muli rd, ra, i        # multiply immediate signed

101111 00000 aaaaa iiiii i ii iiii iiii (opt)   l.sfeqi ra, i
101111 00001 aaaaa iiiii i ii iiii iiii (opt)   l.sfnei ra, i
101111 00010 aaaaa iiiii i ii iiii iiii (opt)   l.sfgtui ra, i
101111 00011 aaaaa iiiii i ii iiii iiii (opt)   l.sfgeui ra, i
101111 00100 aaaaa iiiii i ii iiii iiii (opt)   l.sfltui ra, i
101111 00101 aaaaa iiiii i ii iiii iiii (opt)   l.sfleui ra, i
101111 01010 aaaaa iiiii i ii iiii iiii (opt)   l.sfgtsi ra, i
101111 01011 aaaaa iiiii i ii iiii iiii (opt)   l.sfgesi ra, i
101111 01100 aaaaa iiiii i ii iiii iiii (opt)   l.sfltsi ra, i
101111 01101 aaaaa iiiii i ii iiii iiii (opt)   l.sflesi ra, i

101110 ddddd aaaaa ----- - -- 00-i iiii (opt)   l.slli rd, ra, i
101110 ddddd aaaaa ----- - -- 01-i iiii (opt)   l.srli rd, ra, i
101110 ddddd aaaaa ----- - -- 10-i iiii (opt)   l.srai rd, ra, i
101110 ddddd aaaaa ----- - -- 11-i iiii (opt)   l.rori rd, ra, i

000110 ddddd ----0 iiiii i ii iiii iiii         l.movhi rd, i           # move immediate high

110001 ----- aaaaa bbbbb - -- ---- 0001 (opt)   l.mac           # multiply signed and accumulate
010011 iiiii ----- bbbbb i ii iiii iiii (opt)   l.maci          # multiply immediate signed and accumulate
000110 ddddd ----1 00000 0 00 0000 0000 (opt)   l.macrc         # MAC read and  clear
110001 ----- aaaaa bbbbb - -- ---- 0010 (opt)   l.msb ra, rb    # multply signed and substract


Load/Store
----------

100001 ddddd aaaaa iiiii i ii iiii iiii         l.lwz rd, i(ra) # load word & zero-extend
100010 ddddd aaaaa iiiii i ii iiii iiii         l.lws rd, i(ra) # load word & sign-extend
100011 ddddd aaaaa iiiii i ii iiii iiii         l.lbz rd, i(ra) # load byte & zero-extend
100100 ddddd aaaaa iiiii i ii iiii iiii         l.lbs rd, i(ra) # load byte & sign-extend
100101 ddddd aaaaa iiiii i ii iiii iiii         l.lhz rd, i(ra) # load half word & zero-extend
100110 ddddd aaaaa iiiii i ii iiii iiii         l.lhs rd, i(ra) # load half word & sign-extend

110101 iiiii aaaaa bbbbb i ii iiii iiii         l.sw i(ra), rb  # store word
110110 iiiii aaaaa bbbbb i ii iiii iiii         l.sb i(ra), rb  # store byte
110111 iiiii aaaaa bbbbb i ii iiii iiii         l.sh i(ra), rb  # store half word


New:

111110 ddddd aaaaa iiiii i ii iiii iiii         # load-link

111101 iiiii aaaaa bbbbb i ii iiii iiii         # store conditional

111100 iiiii aaaaa ---10 i ii iiii iiii         # cache writeback
111100 iiiii aaaaa ---01 i ii iiii iiii         # cache invalidate
111100 iiiii aaaaa ---11 i ii iiii iiii         # cache flush


Jumps
-----

000000 nnnnn nnnnn nnnnn n nn nnnn nnnn         l.j N           # jump to exts(4*N)
000001 nnnnn nnnnn nnnnn n nn nnnn nnnn         l.jal N         # jump and link
000011 nnnnn nnnnn nnnnn n nn nnnn nnnn         l.bnf N
000100 nnnnn nnnnn nnnnn n nn nnnn nnnn         l.bf N

000101 01--- ----- kkkkk k kk kkkk kkkk         l.nop K         # NOP

010001 ----- ----- bbbbb - -- ---- ----         l.jr rb         # jump register
010010 ----- ----- bbbbb - -- ---- ----         l.jalr rb       # jump and link register

001000 00000 00000 kkkkk k kk kkkk kkkk         l.sys           # system call
001000 01000 00000 kkkkk k kk kkkk kkkk (opt)   l.trap          # trap exception

001001 ----- ----- ----- - -- ---- ----         l.rfe           # return from exception




Other
-----

101101 ddddd aaaaa kkkkk k kk kkkk kkkk         l.mfspr rd, ra, K      # move from special purpose register
110000 kkkkk aaaaa bbbbb k kk kkkk kkkk         l.mtspr ra, rb, K      # move to special purpose register

001000 10000 00000 00000 0 00 0000 0000 (opt)   l.msync         # memory synchronisation
001000 10100 00000 00000 0 00 0000 0000 (opt)   l.psync         # pipeline synchronisation
001000 11000 00000 00000 0 00 0000 0000 (opt)   l.csync         # context synchronisation

011100 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust1
011101 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust2
011110 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust3
011111 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust4
111100 ddddd aaaaa bbbbb l ll lllk kkkk (opt)   l.cust5 rd, ra, rb, L, K
111101 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust6 (?)
111110 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust7 (?)
111111 xxxxx xxxxx xxxxx x xx xxxx xxxx (opt)   l.cust8 (?)
