#include <stdio.h>
#include <stdlib.h>

#include "paranut.h"
#include "paranut_hist.h"
#include "counter.h"

#define CTR_BA 0xf0000000

// SIZE must be a power of two!
#define SIZE 0x8000
#define MAX_NUMBER 10000

extern unsigned long _board_clk_freq;

int a[SIZE];
int tmp[SIZE];
int sorted;
unsigned int start_time, stop_time;

void do_msort(int n0, int n1, int m)
{
    int i0, i1, j;

    i0 = n0;
    i1 = m+1;
    j = n0;
    while (i0 <= m && i1 <= n1) {
        if (a[i0] <= a[i1]) tmp[j++] = a[i0++];
        else                tmp[j++] = a[i1++];
    }
    while (i0 <= m)  tmp[j++] = a[i0++];
    while (i1 <= n1) tmp[j++] = a[i1++];
    for (j = n0; j <= n1; j++) a[j] = tmp[j];
}

void do_divide (int n0, int n1, int c, int l, int cpu_id, int n_cpus)
{
    int m;

    if (n1 > n0) {
        m = (n0 + n1) / 2;

        if (l >= n_cpus) {
            // Begin sorting for each CPU.
            if (c == cpu_id) {
                // Only sort assigned slice.
                do_divide(n0, m, c, 2*l, cpu_id, n_cpus);
                do_divide(m+1, n1, c, 2*l, cpu_id, n_cpus);
                do_msort(n0, n1, m);
                if (cpu_id != 0 && l == n_cpus)
                    // CPU finished sorting its sub-tree.
                    pn_sync_set(cpu_id);
            } else {
                return;
            }
        } else {
            do_divide(n0, m, 2*c, 2*l, cpu_id, n_cpus);
            do_divide(m+1, n1, 2*c+1, 2*l, cpu_id, n_cpus);
            if (cpu_id == 0) {
                // CPU 0 has to wait here for each CPU to be finished before
                // sorting the remaining array.
                wait_for_cpu(2*c+1);
                do_msort(n0, n1, m);
            }
        }
    }
}

int real_main(int cpu_id)
{
    int i;

    if (cpu_id == 0) {
        counter_init(_board_clk_freq);
        sorted = 1;
        printf("\nGenerating random array of size %d...\n", SIZE);
        for (i = 0; i < SIZE; i++) {
            a[i] = rand() % MAX_NUMBER;
            if (i > 1 && a[i-1] > a[i])
                sorted = 0;
        }
        if (sorted)
            printf("Random array generation failed.\n");
        else
            printf("Random array generated.\n");
        printf("Running merge sort with %d CPU(s)...\n", pn_get_ncpus());
        counter_reset(CTR_BA, 0);
        counter_start(CTR_BA, 0);
        counter_set_cnt_div(CTR_BA, 0, 2);
        start_time = counter_get_msecs(CTR_BA, 0);
        pn_sync_set(0);
    }
    // Wait for random array to be generated by CPU 0...
    wait_for_cpu(0);
    if (cpu_id == 0) {
        pn_sync_unset(0);
    }
    pn_hist_enable();

    // Begin sorting...
    do_divide (0, SIZE-1, 0, 1, cpu_id, pn_get_ncpus());

    pn_hist_disable();

    if (cpu_id == 0) {
        stop_time = counter_get_msecs(CTR_BA, 0);
        printf("Finished sorting...");
        // Check if array is actually sorted.
        sorted = 1;
        for (i = 1; i < SIZE; i++) {
            if (a[i-1] > a[i])
                sorted = 0;
        }
        if (sorted)
            printf(" Correct operation verified.\n");
        else
            printf(" Correct operation could not be verified.\n");
        printf("Time elapsed: %d ms\n", stop_time - start_time);
    }

    if (cpu_id == 0) {
        pn_sync_clear();
    }

    // Print histogram sequentially for every CPU
    if (cpu_id != 0) {
        wait_for_cpu(0);
        wait_for_cpu(cpu_id-1);
    }
    pn_stats_collect();
    //pn_stats_print();
    // Last one to print global stats...
    if (cpu_id == pn_get_ncpus()-1) {
        pn_global_stats_collect();
        pn_global_stats_print();
    }
    pn_sync_set(cpu_id);
    // Do not leave before all is done...
    wait_for_cpu(pn_get_ncpus()-1);

    return sorted-1;
}

int main ()
{
    return real_main(pn_get_cpuid());
}

